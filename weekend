import folium
import geopandas as gpd
import pandas as pd
import numpy as np
from pyproj import Transformer
import os
import webbrowser
from pathlib import Path
from geopy.distance import geodesic
from collections import defaultdict
import heapq
import matplotlib.pyplot as plt
import matplotlib.patches as mpatches

class LocomotiveRouter:
    def __init__(self, shapefile_path, points_data, excel_path):
        #–∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–ª–∞—Å—Å–∞: –∑–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö –¥–æ—Ä–æ–≥, —Ç–æ—á–µ–∫ –∏ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ
        self.roads = gpd.read_file(shapefile_path)
        self.df_points = pd.DataFrame(points_data)
        self.graph = self.build_railway_graph()  #–ø–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ –≥—Ä–∞—Ñ–∞ –∂–µ–ª–µ–∑–Ω—ã—Ö –¥–æ—Ä–æ–≥
        self.service_points = points_data['name']  #—Ç–æ—á–∫–∏ –æ–±—Å–ª—É–∂–∏–≤–∞–Ω–∏—è
        self.excel_path = excel_path  #–ø—É—Ç—å –∫ —Ñ–∞–π–ª—É —Å —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ–º

        #–ø–∞—Ä–∞–º–µ—Ç—Ä—ã –ª–æ–∫–æ–º–æ—Ç–∏–≤–æ–≤: —Ç–∏–ø, –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ, —Å—Ç–æ–∏–º–æ—Å—Ç—å –ø—Ä–æ–±–µ–≥–∞ –∏ –ø—Ä–æ—Å—Ç–æ—è
        self.locomotives = {
            '2–≠–°5–ö': {'count': 28, 'empty_cost': 1065, 'idle_cost': 115},
            '2–≠–°6': {'count': 24, 'empty_cost': 1245, 'idle_cost': 124},
            '2–≠–°7': {'count': 22, 'empty_cost': 1253, 'idle_cost': 129}
        }
        self.loco_states = defaultdict(dict)  #—Å–æ—Å—Ç–æ—è–Ω–∏–µ –∫–∞–∂–¥–æ–≥–æ –ª–æ–∫–æ–º–æ—Ç–∏–≤–∞
        self.initialize_locomotives()  #–æ–±—ä—è–≤–ª–µ–Ω–∏–µ –ª–æ–∫–æ–º–æ—Ç–∏–≤–æ–≤
        self.trains = self.load_train_schedule()  #–∑–∞–≥—Ä—É–∑–∫–∞ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è –ø–æ–µ–∑–¥–æ–≤
        self.total_distance = 0  #–æ–±—â–∏–π –ø—Ä–æ–±–µ–≥

    def build_railway_graph(self):
        #–ø–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ –≥—Ä–∞—Ñ–∞ –∂–µ–ª–µ–∑–Ω—ã—Ö –¥–æ—Ä–æ–≥ –∏–∑ shapefile
        graph = defaultdict(dict)
        transformer = Transformer.from_crs("EPSG:32637", "EPSG:4326", always_xy=True)
        for _, road in self.roads.iterrows():
            if road.geometry.is_empty or road.geometry.geom_type != 'LineString':
                continue  #–ø—Ä–æ–ø—É—Å–∫–∞–µ–º –ø—É—Å—Ç—ã–µ –∏–ª–∏ –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ –≥–µ–æ–º–µ—Ç—Ä–∏–∏
            coords = list(road.geometry.coords)
            converted_coords = [transformer.transform(x, y) for x, y in coords]  #–∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç
            for i in range(len(converted_coords) - 1):
                lon1, lat1 = converted_coords[i]
                lon2, lat2 = converted_coords[i + 1]
                dist = geodesic((lat1, lon1), (lat2, lon2)).km  #—Ä–∞—Å—á–µ—Ç —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—è –º–µ–∂–¥—É —Ç–æ—á–∫–∞–º–∏
                graph[(lat1, lon1)][(lat2, lon2)] = dist  #–¥–æ–±–∞–≤–ª–µ–Ω–∏–µ —Ä–µ–±—Ä–∞ –≤ –≥—Ä–∞—Ñ
                graph[(lat2, lon2)][(lat1, lon1)] = dist  #–æ–±—Ä–∞—Ç–Ω–æ–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
        return graph

    def initialize_locomotives(self):
        #—Å–ª—É—á–∞–π–Ω–æ–µ –Ω–∞—á–∞–ª—å–Ω–æ–µ –ø–æ–ª–æ–∂–µ–Ω–∏–µ
        loco_id = 1
        for loco_type, params in self.locomotives.items():
            for i in range(params['count']):
                start_point = self.df_points.sample(1).iloc[0]  #—Å–ª—É—á–∞–π–Ω–∞—è —Ç–æ—á–∫–∞ —Å—Ç–∞—Ä—Ç–∞
                self.loco_states[loco_id] = {
                    'type': loco_type,
                    'location': (start_point['latitude'], start_point['longitude']),
                    'mileage': 0,  #–ø—Ä–æ–±–µ–≥
                    'available_time': 0,  #–≤—Ä–µ–º—è –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏
                    'next_service': 25000  #–∫–º –¥–æ –¢–û
                }
                loco_id += 1

    def load_train_schedule(self):
        #–∑–∞–≥—Ä—É–∑–∫–∞ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è –ø–æ–µ–∑–¥–æ–≤ –∏–∑ Excel
        trains = []
        try:
            df = pd.read_excel(self.excel_path, sheet_name=0)
            for _, row in df.iterrows():
                start_point = self.find_station_coordinates(row['from'])  #–∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –Ω–∞—á–∞–ª—å–Ω–æ–π —Å—Ç–∞–Ω—Ü–∏–∏
                end_point = self.find_station_coordinates(row['to'])  #–∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –∫–æ–Ω–µ—á–Ω–æ–π —Å—Ç–∞–Ω—Ü–∏–∏
                if start_point is None or end_point is None:
                    continue  # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –ø–æ–µ–∑–¥–∞ —Å –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–º–∏ —Å—Ç–∞–Ω—Ü–∏—è–º–∏
                departure_time = self.time_str_to_minutes(row['–û—Ç–ø—Ä–∞–≤–ª–µ–Ω–∏–µ'])  #–≤—Ä–µ–º—è –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∏—è –≤ –º–∏–Ω—É—Ç–∞—Ö
                duration = self.time_str_to_minutes(row['–í—Ä–µ–º—è –≤ –ø—É—Ç–∏, —á'])  #–¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –≤ –º–∏–Ω—É—Ç–∞—Ö
                trains.append({
                    'id': row['‚Ññ –ø–æ–µ–∑–¥–∞'],
                    'start': (start_point['latitude'], start_point['longitude']),
                    'end': (end_point['latitude'], end_point['longitude']),
                    'departure_time': departure_time,
                    'duration': duration,
                    'required_type': row.iloc[0]  #—Ç–∏–ø —Ç—Ä–µ–±—É–µ–º–æ–≥–æ –ª–æ–∫–æ–º–æ—Ç–∏–≤–∞
                })
        except Exception as e:
            print(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —á—Ç–µ–Ω–∏–∏ —Ñ–∞–π–ª–∞ Excel: {e}")
            for i in range(100):
                start_point = self.df_points.sample(1).iloc[0]
                end_point = self.df_points.sample(1).iloc[0]
                trains.append({
                    'id': i + 1,
                    'start': (start_point['latitude'], start_point['longitude']),
                    'end': (end_point['latitude'], end_point['longitude']),
                    'departure_time': np.random.randint(0, 1440),
                    'duration': np.random.randint(60, 360),
                    'required_type': np.random.choice(['2–≠–°5–ö', '2–≠–°6', '2–≠–°7'])
                })
        return trains

    def find_station_coordinates(self, station_name):
        #–ø–æ–∏—Å–∫ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç —Å—Ç–∞–Ω—Ü–∏–∏ –ø–æ –Ω–∞–∑–≤–∞–Ω–∏—é
        if not station_name or pd.isna(station_name):
            return None
        result = self.df_points[self.df_points['name'].str.contains(station_name, case=False, na=False)]
        if not result.empty:
            return result.iloc[0]
        return None

    def time_str_to_minutes(self, time_str):
        #–∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è —Å—Ç—Ä–æ–∫–∏ –≤—Ä–µ–º–µ–Ω–∏ –≤ –º–∏–Ω—É—Ç—ã
        if pd.isna(time_str):
            return 0
        if isinstance(time_str, str):
            parts = time_str.split(':')
            if len(parts) >= 2:
                try:
                    hours = int(parts[0])
                    minutes = int(parts[1])
                    return hours * 60 + minutes
                except ValueError:
                    return 0
        elif isinstance(time_str, (int, float)):
            return int(time_str * 60)
        return 0

    def find_shortest_path(self, start, end):
        #–ø–æ–∏—Å–∫ –∫—Ä–∞—Ç—á–∞–π—à–µ–≥–æ –ø—É—Ç–∏ –º–µ–∂–¥—É —Ç–æ—á–∫–∞–º–∏ (–∞–ª–≥–æ—Ä–∏—Ç–º –î–µ–π–∫—Å—Ç—Ä—ã)
        heap = [(0, start, [])]  #–æ—á–µ—Ä–µ–¥—å —Å –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–æ–º: (—Å—Ç–æ–∏–º–æ—Å—Ç—å, —Ç–µ–∫—É—â–∞—è —Ç–æ—á–∫–∞, –ø—É—Ç—å)
        visited = set()
        while heap:
            cost, current, path = heapq.heappop(heap)
            if current in visited:
                continue
            visited.add(current)
            path = path + [current]
            if current == end:
                return cost, path  #–Ω–∞–π–¥–µ–Ω –ø—É—Ç—å
            for neighbor, distance in self.graph.get(current, {}).items():
                if neighbor not in visited:
                    heapq.heappush(heap, (cost + distance, neighbor, path))
        return float('inf'), []  #–ø—É—Ç—å –Ω–µ –Ω–∞–π–¥–µ–Ω

    def calculate_path_distance(self, path):
        #—Ä–∞—Å—á–µ—Ç —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—è –ø—É—Ç–∏ –ø–æ —Å–ø–∏—Å–∫—É –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç
        return sum(geodesic(path[i], path[i + 1]).km for i in range(len(path) - 1))

    def assign_locomotives(self):
        #–ª–æ–∫–æ–º–æ—Ç–∏–≤–æ–≤ –Ω–∞ –ø–æ–µ–∑–¥–∞ —Å —É—á–µ—Ç–æ–º —Å—Ç–æ–∏–º–æ—Å—Ç–∏ –∏ –≤—Ä–µ–º–µ–Ω–∏
        assignments = []
        sorted_trains = sorted(self.trains, key=lambda x: x['departure_time'])  #—Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –ø–æ –≤—Ä–µ–º–µ–Ω–∏ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∏—è
        for train in sorted_trains:
            best_cost = float('inf')
            best_loco, best_path, service_needed, service_path_after = None, [], False, []
            for loco_id, loco in self.loco_states.items():
                if loco['type'] != train['required_type'] or loco['available_time'] > train['departure_time']:
                    continue  #–ª–æ–∫–æ–º–æ—Ç–∏–≤ –Ω–µ –ø–æ–¥—Ö–æ–¥–∏—Ç –ø–æ —Ç–∏–ø—É –∏–ª–∏ –∑–∞–Ω—è—Ç
                distance, path = self.find_shortest_path(loco['location'], train['start'])
                if distance == float('inf'):
                    continue  #–ø—É—Ç—å –Ω–µ –Ω–∞–π–¥–µ–Ω
                route_distance = self.calculate_path_distance([train['start'], train['end']])
                total_mileage = loco['mileage'] + distance + route_distance
                needs_service = total_mileage >= loco['next_service']  #–ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏ –¢–û
                cost = distance * self.locomotives[loco['type']]['empty_cost']  #—Å—Ç–æ–∏–º–æ—Å—Ç—å –ø–æ—Ä–æ–∂–Ω–µ–≥–æ –ø—Ä–æ–±–µ–≥–∞
                idle_time = max(0, train['departure_time'] - loco['available_time'])
                cost += idle_time * self.locomotives[loco['type']]['idle_cost']  #—Å—Ç–æ–∏–º–æ—Å—Ç—å –ø—Ä–æ—Å—Ç–æ—è
                if needs_service:
                    service_dist, service_path = self.find_nearest_service_point(train['end'])
                    cost += service_dist * self.locomotives[loco['type']]['empty_cost']  #—Å—Ç–æ–∏–º–æ—Å—Ç—å –¥–æ –¢–û
                if cost < best_cost:
                    best_cost = cost
                    best_loco = loco_id
                    best_path = path
                    service_needed = needs_service
                    service_path_after = service_path if needs_service else []
            if best_loco:
                #—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏–µ –Ω–∞–∑–Ω–∞—á–µ–Ω–∏—è
                assignments.append({
                    'train_id': train['id'],
                    'loco_id': best_loco,
                    'path': best_path,
                    'service_needed': service_needed,
                    'service_path': service_path_after,
                    'cost': best_cost,
                    'distance': self.calculate_path_distance([train['start'], train['end']]),
                    'empty_distance': self.calculate_path_distance(best_path)
                })
                self.total_distance += assignments[-1]['distance']
                #–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è –ª–æ–∫–æ–º–æ—Ç–∏–≤–∞
                loco = self.loco_states[best_loco]
                loco['mileage'] += assignments[-1]['empty_distance'] + assignments[-1]['distance']
                loco['available_time'] = train['departure_time'] + train['duration']
                loco['location'] = train['end']
                if service_needed:
                    loco['next_service'] = 25000  #—Å–±—Ä–æ—Å —Å—á–µ—Ç—á–∏–∫–∞ –¥–æ –¢–û
                else:
                    loco['next_service'] -= assignments[-1]['empty_distance'] + assignments[-1]['distance']
        return assignments

    def find_nearest_service_point(self, location):
        #–ø–æ–∏—Å–∫ –±–ª–∏–∂–∞–π—à–µ–π —Ç–æ—á–∫–∏ –æ–±—Å–ª—É–∂–∏–≤–∞–Ω–∏—è
        min_dist, best_path = float('inf'), []
        for _, point in self.df_points.iterrows():
            target = (point['latitude'], point['longitude'])
            dist, path = self.find_shortest_path(location, target)
            if dist < min_dist:
                min_dist, best_path = dist, path
        return min_dist, best_path

if __name__ == "__main__":
    #–ø—Ä–∏–º–µ—Ä –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –∫–ª–∞—Å—Å–∞
    shapefile_path = Path(r"C:\Users\kozin\Downloads\Telegram Desktop\all_routes_v2\all_routes_v2.shp")
    excel_path = r"C:\Users\kozin\Downloads\Telegram Desktop\routes.xlsx"
    points_data = {
        'name': ['–ë–µ–∫–∞—Å–æ–≤–æ-–¶–µ–Ω—Ç—Ä–∞–ª—å–Ω–æ–µ', '–ü–µ—Ä–æ–≤–æ', '–ê—ç—Ä–æ–ø–æ—Ä—Ç', '–Ø–Ω–∏—á–∫–∏–Ω–æ', '–ö—Ä–∞—Å–Ω–æ–µ',
                 '–ï–ª–µ—Ü', '–ë—Ä—è–Ω—Å–∫-–õ—å–≥–æ–≤—Å–∫–∏–π', '–û—Ä—ë–ª', '–ö—É—Ä–±–∞–∫–∏–Ω—Å–∫–∞—è', '–õ—å–≥–æ–≤-–ö–∏–µ–≤—Å–∫–∏–π',
                 '–¢—É–ª–∞-1-–ö—É—Ä—Å–∫–∞—è', '–õ—É–∂–∫–∏-–û—Ä–ª–æ–≤—Å–∫–∏–µ', '–ö—É—Ä—Å–∫', '–ë–µ–ª–≥–æ—Ä–æ–¥'],
        'longitude': [36.88475, 37.78648, 37.53315, 37.85962, 31.03734,
                      38.4833, 34.3456, 36.0786, 35.1234, 34.5678,
                      37.6543, 36.8765, 36.1876, 36.5987],
        'latitude': [55.40511, 55.7512, 55.8004, 55.65347, 54.68266,
                     52.6167, 53.2345, 52.9654, 54.3210, 53.4567,
                     54.1932, 52.3456, 51.7303, 50.6010]
    }
    router = LocomotiveRouter(shapefile_path, points_data, excel_path)
    assignments = router.assign_locomotives()

    #–≤—ã–≤–æ–¥ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
    total_cost = sum(a['cost'] for a in assignments)
    total_loaded = sum(a['distance'] for a in assignments)
    total_empty = sum(a['empty_distance'] for a in assignments)

    print(f"\nüìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Ä–∞–±–æ—Ç—ã:")
    print(f"–í—Å–µ–≥–æ –Ω–∞–∑–Ω–∞—á–µ–Ω–∏–π: {len(assignments)}")
    print(f"–û–±—â–∞—è —Å—Ç–æ–∏–º–æ—Å—Ç—å: {total_cost:.2f} —Ä—É–±.")
    if assignments:
        print(f"–°—Ä–µ–¥–Ω—è—è —Å—Ç–æ–∏–º–æ—Å—Ç—å –Ω–∞ –ø–æ–µ–∑–¥: {total_cost / len(assignments):.2f} —Ä—É–±.")
    else:
        print(f"–°—Ä–µ–¥–Ω—è—è —Å—Ç–æ–∏–º–æ—Å—Ç—å –Ω–∞ –ø–æ–µ–∑–¥: -")
    print(f"–û–±—â–∏–π –≥—Ä—É–∂–µ–Ω—ã–π –ø—Ä–æ–±–µ–≥: {total_loaded:.1f} –∫–º")
    print(f"–û–±—â–∏–π –ø–æ—Ä–æ–∂–Ω–∏–π –ø—Ä–æ–±–µ–≥: {total_empty:.1f} –∫–º")
